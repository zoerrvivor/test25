// START OF FILE Test25/World/Terrain.cs
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Content;
using System;
using Test25.Utilities;

namespace Test25.World
{
    public class Terrain : IDisposable
    {
        private GraphicsDevice _graphicsDevice;

        // --- CPU Daten für Physik (Kollision) ---
        private Color[] _physicsData; // "Truth" im RAM
        public int Width { get; private set; }
        public int Height { get; private set; }
        public int WaterLevel { get; private set; }

        // --- GPU Daten für Grafik (Rendering) ---
        private RenderTarget2D _terrainRenderTarget; // Die dauerhafte Textur im VRAM
        private Texture2D _craterBrush; // Der "Radiergummi"
        private BlendState _eraserBlendState; // Die Magie zum Löcher schneiden

        // Water Effects
        private float _waveTime;
        private Texture2D _waterTexture;
        private Effect _waterEffect;
        private VertexBuffer _waterVertexBuffer;
        private Texture2D _skyTexture;

        public GraphicsDevice GraphicsDevice => _graphicsDevice;

        public Terrain(GraphicsDevice graphicsDevice, int width, int height)
        {
            _graphicsDevice = graphicsDevice;
            Width = width;
            Height = height;
            WaterLevel = (int)(height * Constants.WaterLevelRatio);

            _physicsData = new Color[Width * Height];

            // 1. RenderTarget erstellen
            // PreserveContents ist wichtig, damit das Bild nicht gelöscht wird, wenn wir es mal nicht zeichnen
            _terrainRenderTarget = new RenderTarget2D(_graphicsDevice, Width, Height, false, 
                SurfaceFormat.Color, DepthFormat.None, 0, RenderTargetUsage.PreserveContents);

            // 2. BlendState für das "Radieren" erstellen
            // Dieser State sorgt dafür, dass dort, wo wir zeichnen, der Alpha-Wert des Ziels auf 0 gesetzt wird.
            _eraserBlendState = new BlendState
            {
                ColorBlendFunction = BlendFunction.Add,
                ColorSourceBlend = Blend.Zero,
                ColorDestinationBlend = Blend.One, // Farbe behalten (ist eh schwarz/transparent relevant)
                
                AlphaBlendFunction = BlendFunction.Add,
                AlphaSourceBlend = Blend.Zero,
                AlphaDestinationBlend = Blend.InverseSourceAlpha // Wo der Pinsel deckt (1), wird das Ziel (0)
            };

            // Pinsel erstellen (Radius 50 ist nur die Texturgröße, skaliert wird beim Zeichnen)
            _craterBrush = TextureGenerator.CreateSoftCircleTexture(_graphicsDevice, 50);

            _skyTexture = TextureGenerator.CreateGradientTexture(_graphicsDevice, 1, 512, 
                Color.CornflowerBlue, Color.DeepSkyBlue);
            
            _waterTexture = TextureGenerator.CreateNoiseTexture(_graphicsDevice, 64, 64, 
                new Color(0, 0, 200, 150), new Color(0, 0, 255, 150));
        }

        public void Generate(int seed)
        {
            Random rand = new(seed);
            int size = Constants.TerrainGenerationSize;
            float[] map = new float[size];

            map[0] = Height / 2 + rand.Next(-100, 100);
            map[size - 1] = Height / 2 + rand.Next(-100, 100);

            Divide(map, 0, size - 1, Constants.TerrainDisplacement, Constants.TerrainRoughness, rand);

            // Reset Physics Data
            for (int i = 0; i < _physicsData.Length; i++) _physicsData[i] = Color.Transparent;
            Color groundColor = Color.SaddleBrown; // Etwas dunkler für besseren Kontrast

            // Fill Physics Array
            for (int x = 0; x < Width; x++)
            {
                int index = (int)((float)x / Width * (size - 1));
                int h = (int)MathHelper.Clamp(map[index], Constants.TerrainMinHeight, Height - Constants.TerrainMaxHeightOffset);

                for (int y = h; y < Height; y++)
                {
                    _physicsData[y * Width + x] = groundColor;
                }
            }

            // Initial GPU Upload
            // Wir machen das EINMAL am Anfang des Spiels. Hier ist SetData okay.
            UpdateRenderTargetFull();
        }

        // Hilfsmethode, um das CPU-Array komplett auf die GPU zu schieben (nur bei Init)
        private void UpdateRenderTargetFull()
        {
            // Temporäre Textur erstellen, um Daten hochzuladen
            Texture2D tempTex = new Texture2D(_graphicsDevice, Width, Height);
            tempTex.SetData(_physicsData);

            // Auf das RenderTarget zeichnen
            _graphicsDevice.SetRenderTarget(_terrainRenderTarget);
            _graphicsDevice.Clear(Color.Transparent);
            
            using (SpriteBatch sb = new SpriteBatch(_graphicsDevice))
            {
                sb.Begin();
                sb.Draw(tempTex, Vector2.Zero, Color.White);
                sb.End();
            }

            _graphicsDevice.SetRenderTarget(null); // Zurück zum Backbuffer
            tempTex.Dispose();
        }

        // Rekursive Terrain-Funktion (unverändert)
        private static void Divide(float[] map, int left, int right, float displacement, float roughness, Random rand)
        {
            if (right - left <= 1) return;
            int mid = (left + right) / 2;
            float average = (map[left] + map[right]) / 2;
            float change = (float)(rand.NextDouble() * 2 - 1) * displacement;
            map[mid] = average + change;
            float newDisplacement = displacement * roughness;
            Divide(map, left, mid, newDisplacement, roughness, rand);
            Divide(map, mid, right, newDisplacement, roughness, rand);
        }

        // --- SCHNELLE GPU ZERSTÖRUNG ---
        public void Destruct(int cx, int cy, int radius)
        {
            // 1. GPU: Loch schneiden (Visuell)
            // Wir zeichnen auf das RenderTarget, nicht auf den Bildschirm!
            _graphicsDevice.SetRenderTarget(_terrainRenderTarget);
            
            // Wichtig: Keinen Clear() aufrufen, wir wollen das bestehende Bild behalten!
            
            using (SpriteBatch sb = new SpriteBatch(_graphicsDevice))
            {
                // Hier nutzen wir unseren "Eraser" BlendState
                sb.Begin(SpriteSortMode.Immediate, _eraserBlendState);
                
                // Berechne Position und Skalierung für den Pinsel
                // Der Pinsel ist z.B. 100x100px. Wenn Radius 40 ist, Durchmesser 80. Scale = 0.8
                float scale = (radius * 2f) / _craterBrush.Width;
                Vector2 origin = new Vector2(_craterBrush.Width / 2f, _craterBrush.Height / 2f);
                
                sb.Draw(_craterBrush, new Vector2(cx, cy), null, Color.White, 0f, origin, scale, SpriteEffects.None, 0f);
                
                sb.End();
            }

            // Zurücksetzen
            _graphicsDevice.SetRenderTarget(null);


            // 2. CPU: Array updaten (Physik)
            // Wir müssen weiterhin wissen, wo Pixel sind, aber wir iterieren nur über das kleine Rechteck
            int radiusSq = radius * radius;
            int minX = Math.Max(0, cx - radius);
            int maxX = Math.Min(Width - 1, cx + radius);
            int minY = Math.Max(0, cy - radius);
            int maxY = Math.Min(Height - 1, cy + radius);

            for (int y = minY; y <= maxY; y++)
            {
                for (int x = minX; x <= maxX; x++)
                {
                    int dx = x - cx;
                    int dy = y - cy;
                    if (dx * dx + dy * dy < radiusSq)
                    {
                        // Einfach auf Transparent setzen im RAM
                        _physicsData[y * Width + x] = Color.Transparent;
                    }
                }
            }
        }

        // Hinzufügen (Construct) - z.B. für Dirt Gun
        public void Construct(int cx, int cy, int radius)
        {
            // 1. GPU: Zeichnen (Normaler BlendState)
            _graphicsDevice.SetRenderTarget(_terrainRenderTarget);
            using (SpriteBatch sb = new SpriteBatch(_graphicsDevice))
            {
                sb.Begin(); // Default ist AlphaBlend (Additiv)
                
                float scale = (radius * 2f) / _craterBrush.Width;
                Vector2 origin = new Vector2(_craterBrush.Width / 2f, _craterBrush.Height / 2f);
                
                sb.Draw(_craterBrush, new Vector2(cx, cy), null, Color.SaddleBrown, 0f, origin, scale, SpriteEffects.None, 0f);
                
                sb.End();
            }
            _graphicsDevice.SetRenderTarget(null);

            // 2. CPU: Physik updaten
            int radiusSq = radius * radius;
            int minX = Math.Max(0, cx - radius);
            int maxX = Math.Min(Width - 1, cx + radius);
            int minY = Math.Max(0, cy - radius);
            int maxY = Math.Min(Height - 1, cy + radius);

            for (int y = minY; y <= maxY; y++)
            {
                for (int x = minX; x <= maxX; x++)
                {
                    int dx = x - cx;
                    int dy = y - cy;
                    if (dx * dx + dy * dy < radiusSq)
                    {
                        // Nur leere Pixel füllen?
                         if (_physicsData[y * Width + x].A == 0)
                        {
                            _physicsData[y * Width + x] = Color.SaddleBrown;
                        }
                    }
                }
            }
        }

        // Physik-Abfragen nutzen NUR das schnelle RAM-Array
        public bool IsPixelSolid(int x, int y)
        {
            if (x < 0 || x >= Width || y < 0 || y >= Height) return false;
            return _physicsData[y * Width + x].A > 0;
        }

        // Legacy Support für Spawning / Roller (Höhe finden)
        public int GetHeight(int x)
        {
            if (x < 0) x = 0;
            if (x >= Width) x = Width - 1;
            for (int y = 0; y < Height; y++)
            {
                if (_physicsData[y * Width + x].A > 0) return y;
            }
            return Height;
        }
        
        public void Update(GameTime gameTime)
        {
            _waveTime += (float)gameTime.ElapsedGameTime.TotalSeconds;
            // Keine SetData Logik mehr nötig!
        }

        public void DrawSky(SpriteBatch spriteBatch)
        {
            spriteBatch.Draw(_skyTexture, new Rectangle(0, 0, Width, Height), Color.White);
        }

        public void Draw(SpriteBatch spriteBatch)
        {
            // Wir zeichnen einfach das RenderTarget als Textur
            spriteBatch.Draw(_terrainRenderTarget, Vector2.Zero, Color.White);
        }

        // Water Drawing Code (unverändert, nutzt aber jetzt _terrainRenderTarget nicht mehr direkt, da Wasser drüber liegt)
        // ... LoadContent und DrawWater Methoden können so bleiben wie in deinem Original ...

        public void DrawWater(SpriteBatch spriteBatch, Matrix viewTransform)
        {
            // Set shader parameters
            _waterEffect?.Parameters["WaveTime"]?.SetValue(_waveTime);
            _waterEffect?.Parameters["WaterTexture"]?.SetValue(_waterTexture);

            // Standard Orthographic Projection for 2D
            var projection = Matrix.CreateOrthographicOffCenter(0, Width, Height, 0, 0, 1);

            // Combine with Camera View (Shake/Zoom/Pan)
            // WorldViewProjection = World * View * Projection
            // Here our "World" is Identity (sprites are already at world pos).
            // So we need View * Projection. 
            // Note: SpriteBatch transform serves as the View matrix usually.

            Matrix wvp = viewTransform * projection;

            _waterEffect?.Parameters["WorldViewProjection"]?.SetValue(wvp);

            // End SpriteBatch to switch to GPU rendering
            spriteBatch.End();

            // Apply effect and draw full-screen quad for water
            if (_waterEffect != null)
                foreach (EffectPass pass in _waterEffect.CurrentTechnique.Passes)
                {
                    pass.Apply();
                    _graphicsDevice.SetVertexBuffer(_waterVertexBuffer);
                    _graphicsDevice.DrawPrimitives(PrimitiveType.TriangleStrip, 0, 2);
                }

            // Reset vertex buffer
            _graphicsDevice.SetVertexBuffer(null);

            // Restart SpriteBatch with the same transform for consistency if caller continues drawing
            spriteBatch.Begin(SpriteSortMode.Deferred, null, null, null, null, null, viewTransform);
        }

        public void LoadContent(ContentManager content)
        {
             _waterEffect = content.Load<Effect>("Effects/WaterEffect");

            // Create Fullscreen Quad for Water
            float margin = Constants.WaterMargin;
            float left = -margin;
            float right = Width + margin;
            float bottom = Height + margin;
            float top = WaterLevel;

            var vertices = new VertexPositionTexture[4];
            vertices[0] = new VertexPositionTexture(new Vector3(left, top, 0), new Vector2(0, 0));
            vertices[1] = new VertexPositionTexture(new Vector3(right, top, 0), new Vector2(1, 0));
            vertices[2] = new VertexPositionTexture(new Vector3(left, bottom, 0), new Vector2(0, 1));
            vertices[3] = new VertexPositionTexture(new Vector3(right, bottom, 0), new Vector2(1, 1));

            _waterVertexBuffer = new VertexBuffer(_graphicsDevice, typeof(VertexPositionTexture), 4, BufferUsage.WriteOnly);
            _waterVertexBuffer.SetData(vertices);
        }

        // Dekorations-Stamping (für Ruinen) muss auch angepasst werden
        public void Blit(Texture2D source, int x, int y)
        {
            // 1. GPU
            _graphicsDevice.SetRenderTarget(_terrainRenderTarget);
            using (SpriteBatch sb = new SpriteBatch(_graphicsDevice))
            {
                sb.Begin();
                sb.Draw(source, new Vector2(x, y), Color.White);
                sb.End();
            }
            _graphicsDevice.SetRenderTarget(null);

            // 2. CPU
            Color[] sourceData = new Color[source.Width * source.Height];
            source.GetData(sourceData);
            
            int startX = Math.Max(0, x);
            int startY = Math.Max(0, y);
            int endX = Math.Min(Width, x + source.Width);
            int endY = Math.Min(Height, y + source.Height);

            for (int py = startY; py < endY; py++)
            {
                for (int px = startX; px < endX; px++)
                {
                    int srcX = px - x;
                    int srcY = py - y;
                    Color srcPixel = sourceData[srcY * source.Width + srcX];
                    if (srcPixel.A > 0)
                    {
                        _physicsData[py * Width + px] = srcPixel;
                    }
                }
            }
        }

        public void Dispose()
        {
            _terrainRenderTarget?.Dispose();
            _craterBrush?.Dispose();
            _skyTexture?.Dispose();
            _waterTexture?.Dispose();
            _waterVertexBuffer?.Dispose();
        }
    }
}